ebpf
====

## 1. requirements
  in general, there are 3 approaches to use ebpf.
  1) Using bcc tools python interface
  we install bcc-tools by dnf to install bcc python libs,
  sometimes need to use pip3 install bcc to install the library.
  we also need to install kernel-headers which is used to
  compile python codes to bpf programs.
  2) Using bpftrace
  install bpftrace by dnf, usage just like systemtap
  3) Using libbpf in C
  there were some efficient tools to use libbpf, but need
  library about libbpf and libbpf-devel packages.

  Refs:
  1) operator instruction
  https://github.com/iovisor/bpf-docs/blob/master/eBPF.md

## 2. build dependence
  for self-compiled linux, we can build bpftool individually.
  bpftool is tool for inspect and manage BPF programs and maps
  in the Linux kernel.
  1) build linux kernel
  CONFIG_BPF=y
  CONFIG_BPF_SYSCALL=y
  CONFIG_BPF_JIT=y
  CONFIG_HAVE_EBPF_JIT=y
  CONFIG_BPF_EVENTS=y
  CONFIG_FTRACE=y
  CONFIG_FUNCTION_TRACER=y
  CONFIG_HAVE_DYNAMIC_FTRACE=y
  CONFIG_DEBUG_INFO_BTF=y

  for self-built kernel, we also need linux headers for bcc and libbpf,
  which is an archive of headers:
  CONFIG_IKHEADERS=y

  BTF: btf is the base of CO-RE, which supply BPF program and Map debuginfo.
  BTF relative to DWARF, which have smaller size, speed load performance.
  BTF include function and source code link information and data struction,
  including BTF's BPF program wich is labeled with source code, then output
  can be decoratored with more detail information.
  so with BTF program is the self-description.

  use bpftool can generate a vmlinux.h file, which is the program layout.

  2) build linux and bpf tools, which can generate bpftool
  $ cd linux; make tools/bpf

  3) compile tools dependences
  for bcc:
    bcc is one of the solutions for BPF portability. but it comes with runtime overhead
    and a large binary size from embedding the compiler with the application.
    and in compile time, it need lots of dependences.
    need include linux header, so after compiled IKHEADERS we had
    a kernel/kheaders_data.tar.xz file under linux source code, we
    need to decompress it to a path, usually we depcompress it to
    '/lib/modules/$(uname -r)/build', if the path is not exsit, we
    should create it. or set global enviroment:
    BCC_KERNEL_SOURCE=/share/bpf-kernel-head/

  for bpftrace:
    only need to install bpftrace by dnf install

  for libbpf:
    libbpf is a C-based library containing a BPF loader that takes compiled BPF object files
    and prepares and loads them into the Linux kernel. libbpf takes the heavy lifting of loading,
    verifying, and attaching BPF programs to various kernel hooks, allowing BPF application
    developers to focus only on BPF program correctness and performance.
    BPF skeleton is an alternative interface to libbpf APIs for working with BPF objects. Skeleton
    code abstract away generic libbpf APIs to significantly simplify code for manipulating BPF programs
    from user space. Skeleton code includes a bytecode representation of the BPF object file, simplifying
    the process of distributing your BPF code. With BPF bytecode embedded, there are no extra files
    to deploy along with your application binary.
    Using the skeleton code is the recommended way to work with bpf programs. Keep in mind, BPF skeleton
    provides access to the underlying BPF object, so whatever was possible to do with generic libbpf APIs
    is still possible even when the BPF skeleton is used. It’s an additive convenience feature, with no
    syscalls, and no cumbersome code. 

    for installation: need to install libbpf and libbpf-devel by dnf install, also
    need to generate vmlinux.h then we can use linux symbols directly
    in bpf programs.
    if you have the linux source, we can generate the vmlinux.h by bpftool.
    ./tools/bpf/bpftool/bpftool btf dump file vmlinux format c > vmlinux.h
    or using make tools/bpf which had generated the file located in
    ./tools/bpf/bpftool/vmlinux.h
   it is much more effient than bcc, libbpf steps up the BPF program portability
   by supporting the BPF CO-RE(compile Onetime, run everywhere) concept.
   libbpf is precompiled, but in bcc which is runtime compiled.
   refs: https://docs.kernel.org/bpf/libbpf/libbpf_overview.html

## 3. principle:
  All the tools are convenient to compile BPF source code to BPF programs, then
  via BPF() syscall load into kernel, called by kernel context, like bpf_get_current_pid_tgid.

## 4. usage
  1) bcc:
    refs: https://github.com/iovisor/bcc.git 
    python bcc_program.py
 
  2) bpftrace:
    "bpftrace -l" lists all probes, and a search term can be added.

    - The word `BEGIN` is a special probe that fires at the start of the program (like awk's BEGIN).
      You can use it to set variables and print headers.
    - An action can be associated with probes, in { }. This example calls printf() when the probe fires.
    # bpftrace -e 'BEGIN { printf("hello world\n"); }'

    Files open:
    Tracepoints are preferred over kprobes
    - `comm` is a builtin variable that has the current process's name. Other similar builtins include pid and tid.
    - `args` is a struct containing all the tracepoint arguments. This
       struct is automatically generated by bpftrace based tracepoint information. The
       members of this struct can be found with: `bpftrace -vl tracepoint:syscalls:sys_enter_openat`.
    - `args.filename` accesses the `args` struct and gets the value of the `filename` member.
    - `str()` turns a pointer into the string it points to.
    # bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args.filename)); }'

    Syscall Counts By Process:
    This summarizes syscalls by process name, printing a report on Ctrl-C.
    - @: This denotes a special variable type called a map, which can store and summarize data in different ways. You can add an optional variable name after the @, eg "@num", either to improve readability, or to differentiate between more than one map.
   - []: The optional brackets allow a key to be set for the map, much like an associative array.
   - count(): This is a map function – the way it is populated. count() counts the number of times it is called. Since this is saved by comm, the result is a frequency count of system calls by process name.
    # bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'

    Distribution of read() Bytes:
    - /.../: This is a filter (aka predicate), which acts as a filter for the action. The action is only executed if the filtered expression is true, in this case, only for the process ID 18644. Boolean operators are supported ("&&", "||").
    - ret: This is the return value of the function. For sys_read(), this is either -1 (error) or the number of bytes successfully read.
    - @: This is a map similar to the previous lesson, but without any keys ([]) this time, and the name "bytes" which decorates the output.
    - hist(): This is a map function which summarizes the argument as a power-of-2 histogram. The output shows rows that begin with interval notation, where, for example `[128, 256)` means that the value is: 128 <= value < 256. The next number is the count of occurrences, and then an ASCII histogram is printed to visualize that count. The histogram can be used to study multi-modal distributions.
    - Other map functions include lhist() (linear hist), count(), sum(), avg(), min(), and max().
    # bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args.ret); }'

    Kernel Dynamic Tracing of read() Bytes:
    - It begins with the probe `kretprobe:vfs_read`: this is the kretprobe probe type (kernel dynamic tracing of function returns) instrumenting the `vfs_read()` kernel function. There is also the kprobe probe type (shown in the next lesson), to instrument when functions begin execution (are entered). These are powerful probe types, letting you trace tens of thousands of different kernel functions. However, these are "unstable" probe types: since they can trace any kernel function, there is no guarantee that your kprobe/kretprobe will work between kernel versions, as the function names, arguments, return values, and roles may change. Also, since it is tracing the raw kernel, you'll need to browse the kernel source to understand what these probes, arguments, and return values, mean.
    - lhist(): this is a linear histogram, where the arguments are: value, min, max, step. The first argument (`retval`) of vfs_read() is the return value: the number of bytes read.
    # bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'

    Timing read()s:
    - @start[tid]: This uses the thread ID as a key. There may be many reads in-flight, and we want to store a start timestamp to each. How? We could construct a unique identifier for each read, and use that as the key. But because kernel threads can only be executing one syscall at a time, we can use the thread ID as the unique identifier, as each thread cannot be executing more than one.
    - nsecs: Nanoseconds since boot. This is a high resolution timestamp counter than can be used to time events.
    - /@start[tid]/: This filter checks that the start time was seen and recorded. Without this filter, this program may be launched during a read and only catch the end, resulting in a time calculation of now - zero, instead of now - start.
    - delete(@start[tid]): this frees the variable.
    # bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'

    Count process-level events for five seconds, printing a summary:
    - sched: The `sched` probe category has high-level scheduler and process events, such as fork, exec, and context switch.
    - probe: The full name of the probe.
    - interval:s:5: This is a probe that fires once every 5 seconds, on one CPU only. It is used for creating script-level intervals or timeouts.
    - exit(): This exits bpftrace.
    # bpftrace -e 'tracepoint:sched:sched* { @[probe] = count(); } interval:s:5 { exit(); }'

    Profile On-CPU Kernel Stacks:
    Profile kernel stacks at 99 Hertz, printing a frequency count.
    - profile:hz:99: This fires on all CPUs at 99 Hertz. Why 99 and not 100 or 1000? We want frequent enough to catch both the big and small picture of execution, but not too frequent as to perturb performance. 100 Hertz is enough. But we don't want 100 exactly, as sampling may occur in lockstep with other timed activities, hence 99.
    - kstack: Returns the kernel stack trace. This is used as a key for the map, so that it can be frequency counted. The output of this is ideal to be visualized as a flame graph. There is also `ustack` for the user-level stack trace.
    # bpftrace -e 'profile:hz:99 { @[kstack] = count(); }'

    Block I/O Tracing:
    - tracepoint:block: The block category of tracepoints traces various block I/O (storage) events.
    - block_rq_issue: This fires when an I/O is issued to the device.
    - args.bytes: This is a member from the tracepoint block_rq_issue arguments which shows the size in bytes.
    # bpftrace -e 'tracepoint:block:block_rq_issue { @ = hist(args.bytes); }'

    Kernel Struct Tracing:
    This uses kernel dynamic tracing of the vfs_open() function, which has a (struct path *) as the first argument.
    - kprobe: As mentioned earlier, this is the kernel dynamic tracing probe type, which traces the entry of kernel functions (use kretprobe to trace their returns).
    - `arg0` is a builtin variable containing the first probe argument, the meaning of which is defined by the probe type. For `kprobe`, it is the first argument to the function. Other arguments can be accessed as arg1, ..., argN.
    - `((struct path *)arg0)->dentry->d_name.name`: this casts `arg0` as `struct path *`, then dereferences dentry, etc.
    - #include: these are necessary to include struct definitions for path and dentry on systems where the kernel was built without BTF  (BPF Type Format) data.
    # bpftrace path.bt
    # cat path.bt
    #ifndef BPFTRACE_HAVE_BTF
    #include <linux/path.h>
    #include <linux/dcache.h>
    #endif

    kprobe:vfs_open
    {
        printf("open path: %s\n", str(((struct path *)arg0)->dentry->d_name.name));
    }


  3) libbpf:
    refs: https://libbpf.readthedocs.io/en/latest/api.html
    https://eunomia.dev/en/tutorials/1-helloworld/

    in general:
    at first, write bpf program, like min.bpf.c:
    ```
// Include necessary headers
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <linux/ptrace.h>

char LICENSE[] SEC("license") = "GPL";

SEC("kprobe/do_sys_open")
int bpf_prog(struct pt_regs *ctx)
{
    bpf_printk("Hello, World!\n");
    return 0;
}
    ```
    compile the bpf object file.
    $ clang -O2 -target bpf -c minimal.bpf.c -o minimal.bpf.o

    we also can use 'bpftool gen skeleton' to generate a *.skel.h code,
    which include bpf bytecode and functions.

    (1) common head file

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

    (2) define Map object and program type

  struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __unit(max_entries, 10240);
    __type(key, u32);
    __type(value, struct my_value);
  } my_hash_map SEC(".maps")

    when need to manager data in Maps, we can use blow code to get loaded BCC or libbpf probes.

  #ifdef __BCC__
    struct event *data = heap.lookup(&zero);
  #else
    struct event *data = bpf_map_lookup_eleme(&help, &zero);
  #endif

  #ifdef __BCC__
    my_hash_map.update(&id, my_val);
  #else
    bpf_map_update_elem(&my_hash_map, &id, &my_val, 0);
  #endif

  #ifdef __BCC__
    events.perf_submit(args, data, data_len);
  #else
    bpf_perf_event_output(args, &events, BPF_F_CURRENT_CPU, data, data_len); // write to perf buffer
  #endif

  for CO-RE eBPF program, must use SEC() marco to define type, like:

  SEC("ksyscall/execve")
  in BPF_KPROBE_SYSCALL(kprobe_sys_execve, const char *pathname)

  for ksyscall, we also can use bpf_program__attach_ksysall() to adhere to target kprobe function.
  otherwise, if we want to access field use "->", in bpf, we must use bpf_probe_read_kernel() function
  to get values.

    secondary, write C loader.c to load bpf prog:
    loader.c
    ```
#include <stdio.h>
#include <bpf/libbpf.h>

// Define the print function
static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)
{
    return vfprintf(stderr, format, args);
}

int main(int argc, char **argv)
{
    struct bpf_object *obj;
    struct bpf_program *prog;
    int err;

    // Set up libbpf errors and debug info callback
    libbpf_set_print(libbpf_print_fn);

    // Open and load BPF program
    obj = bpf_object__open("minimal.bpf.o");
    if (!obj) {
        fprintf(stderr, "Error opening object\n");
        return 1;
    }

    // Load BPF program
    err = bpf_object__load(obj);
    if (err) {
        fprintf(stderr, "Error loading object: %d\n", err);
        goto cleanup;
    }

    // Find and attach BPF program
    prog = bpf_object__find_program_by_name(obj, "handle_tp");
    if (!prog) {
        fprintf(stderr, "Error finding program\n");
        goto cleanup;
    }

    // Attach the program
    err = bpf_program__attach(prog);
    if (!err) {
        fprintf(stderr, "Error attaching program: %s\n", strerror(-libbpf_get_error(err)));
        goto cleanup;
    }

    printf("Successfully loaded and attached BPF program\n");

    // Keep the program running
    while (1) {
        sleep(1);
    }

cleanup:
    bpf_object__close(obj);
    return err;
}
    ```
    $ gcc loader.c -o loader -lbpf

    then load bpf and get trace output:
    loader min.bpf.o
    cat /sys/kernel/debug/tracing/trace / trace_pipe


### effcient bpf tools:
   refs: https://eunomia.dev/en/tutorials/1-helloworld/#installing-the-necessary-software-and-tools
   get compiled tool file:
    loader file:
    $ wget https://aka.pw/bpf-ecli -O ecli && chmod +x ./ecli
    bpf compile tool:
    $ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc && chmod +x ./ecc

    compile it:
     ./ecc minimal.bpf.c
     ./ecli run package.json

    After running this program, you can view the output of the eBPF program by checking the /sys/kernel/debug/tracing/trace_pipe file.

### BPF API (implement in kernel: kernel/bpf/helpers.c) 
1. bpf_map_lookup_elem(map, key): find value with key in maptable
2. bpf_map_update_elem(map, key, value, flags): update value with key in maptable
3. bpf_map_delete_elem(map, key): delete it
4. bpf_probe_read(dst, size, src): read size from src and store into dst
5. bpf_ktime_get_ns(): return ns from sys boot
6. bpf_trace_printk()
7. bpf_get_current_pid_tgid()
8. bpf_get_current_comm(buf, buf_size)
9. bpf_perf_event_output(ctx, map, data, size): write to perf_event ringbuffer, and output every event
10. bpf_get_stackid/ bpf_get_current_task
11. bpf_probe_read_str(dst, size, ptr): read size from an unsafe ptr and write to dst
12. bpf_perf_event_read_value
13. bpf_get_current_cgroup_id
14. bpf_spin_lock/unlock

### BPF syscall // can be caught by strace
1. BPF_MAP_CREATE
2. BPF_MAP_LOOKUP_ELEM
3. BPF_MAP_UPDATE_ELEM
4. BPF_MAP_DELETE_ELEM
5. BPF_MAP_GET_NEXT_KEY
6. BPF_PROG_LOAD
7. BPF_PROG_ATTACH
8. BPF_PROG_DETACH
9. BPF_OBJ_PIN
